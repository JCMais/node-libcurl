/**
 * Copyright (c) Jonathan Cardoso Machado. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { Readable } from 'stream'

/**
 * Common properties shared by all MIME part types.
 *
 * @public
 */
export interface CurlyMimePartCommon {
  /**
   * The field name for this MIME part.
   */
  name: string

  /**
   * The MIME type for this part.
   * If not provided, libcurl will try to determine it automatically.
   */
  mimeType?: string

  /**
   * The filename to send in the Content-Disposition header.
   * If not provided, defaults to the basename of the file path for file types.
   */
  fileName?: string

  /**
   * Content transfer encoding: 'binary', '8bit', '7bit', 'base64', or 'quoted-printable'.
   */
  encoder?: 'binary' | '8bit' | '7bit' | 'base64' | 'quoted-printable'

  /**
   * Custom headers for this MIME part.
   * Each header should be in the format "Header-Name: value".
   */
  headers?: string[]
}

/**
 * MIME part with inline string or Buffer data.
 *
 * @example
 * ```typescript
 * {
 *   type: 'data',
 *   name: 'username',
 *   data: 'john_doe'
 * }
 * ```
 *
 * @public
 */
export interface CurlyMimePartData extends CurlyMimePartCommon {
  type: 'data'
  /**
   * The data content as a string or Buffer.
   */
  data: string | Buffer
}

/**
 * MIME part with data from a file.
 *
 * @example
 * ```typescript
 * {
 *   type: 'file',
 *   name: 'document',
 *   file: '/path/to/document.pdf',
 *   mimeType: 'application/pdf'
 * }
 * ```
 *
 * @public
 */
export interface CurlyMimePartFile extends CurlyMimePartCommon {
  type: 'file'
  /**
   * This is a path to the file to upload.
   * The file is streamed during transfer for memory efficiency.
   */
  file: string
}

/**
 * MIME part with data from a Node.js Readable stream.
 *
 * @remarks
 * The `unpause` callback is automatically generated by Curly, so you don't need to provide it.
 * The stream will be kept in paused mode and read synchronously as curl requests data.
 *
 * @example
 * ```typescript
 * import { createReadStream } from 'fs'
 *
 * {
 *   type: 'stream',
 *   name: 'document',
 *   stream: createReadStream('/path/to/file.txt'),
 *   size: 12345  // optional, for Content-Length header
 * }
 * ```
 *
 * @public
 */
export interface CurlyMimePartStream extends CurlyMimePartCommon {
  type: 'stream'
  /**
   * Node.js Readable stream to read data from.
   */
  stream: Readable
  /**
   * Optional expected total size in bytes for the Content-Length header.
   * If not provided, a large default value is used.
   * -1 works for unknown sizes.
   */
  size?: number
}

/**
 * MIME part with nested subparts (multipart within multipart).
 *
 * @remarks
 * This allows creating nested MIME structures. The ownership of the nested
 * MIME structure transfers to this part.
 *
 * Do NOT use encoding with multipart content (subparts).
 *
 * @example
 * ```typescript
 * {
 *   type: 'subparts',
 *   name: 'multipart_section',
 *   parts: [
 *     { type: 'data', name: 'nested_field1', data: 'nested value 1' },
 *     { type: 'data', name: 'nested_field2', data: 'nested value 2' }
 *   ]
 * }
 * ```
 *
 * @public
 */
export interface CurlyMimePartSubparts extends CurlyMimePartCommon {
  type: 'subparts'
  /**
   * Array of nested MIME parts.
   * These parts can themselves contain subparts, allowing for arbitrary nesting.
   */
  parts: CurlyMimePart[]
}

/**
 * Union type for all possible MIME part configurations.
 *
 * @public
 */
export type CurlyMimePart =
  | CurlyMimePartData
  | CurlyMimePartFile
  | CurlyMimePartStream
  | CurlyMimePartSubparts
